{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "aging-davis",
   "metadata": {},
   "source": [
    "# Demonstration of user interaction with types defined in the cnnclustering package"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "listed-utilization",
   "metadata": {
    "toc": true
   },
   "source": [
    "<h1>Table of Contents<span class=\"tocSkip\"></span></h1>\n",
    "<div class=\"toc\"><ul class=\"toc-item\"><li><span><a href=\"#Labels\" data-toc-modified-id=\"Labels-1\"><span class=\"toc-item-num\">1&nbsp;&nbsp;</span>Labels</a></span></li><li><span><a href=\"#Clustering\" data-toc-modified-id=\"Clustering-2\"><span class=\"toc-item-num\">2&nbsp;&nbsp;</span>Clustering</a></span></li></ul></div>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "modular-ownership",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:41:02.761310Z",
     "start_time": "2021-06-23T10:40:59.705040Z"
    }
   },
   "outputs": [],
   "source": [
    "from cnnclustering import cluster\n",
    "from cnnclustering import _types"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "allied-introduction",
   "metadata": {},
   "source": [
    "## Labels"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "spread-murder",
   "metadata": {},
   "source": [
    "Initialize as\n",
    "\n",
    "  - `Labels(labels)`\n",
    "  - `Labels(labels, consider=consider)`\n",
    "  - `Labels(labels, consider=consider, meta=meta)`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "academic-cincinnati",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:41:28.651001Z",
     "start_time": "2021-06-23T10:41:28.642819Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on class Labels in module cnnclustering._types:\n",
      "\n",
      "class Labels(builtins.object)\n",
      " |  Represents cluster label assignments\n",
      " |  \n",
      " |  Args:\n",
      " |      labels: A container of integer cluster labels\n",
      " |          supporting the buffer protocol\n",
      " |  \n",
      " |  Keyword args:\n",
      " |      consider: A boolean (uint8) container of same length as `labels`\n",
      " |          indicating if a cluster label should be considered for assignment\n",
      " |          during clustering.  If `None`, will be created as all true.\n",
      " |      meta: Meta information.  If `None`, will be created as empty\n",
      " |          dictionary.\n",
      " |  \n",
      " |  Attributes:\n",
      " |      n_points: The length of the labels container\n",
      " |      meta: The meta information dictionary\n",
      " |      labels: The labels container converted to a NumPy ndarray\n",
      " |      consider: The consider container converted to a NumPy ndarray\n",
      " |      mapping: A mapping of cluster labels to indices in `labels`\n",
      " |      set: The set of cluster labels\n",
      " |      consider_set: A set of cluster labels to consider for cluster\n",
      " |          label assignments\n",
      " |  \n",
      " |  Methods defined here:\n",
      " |  \n",
      " |  __reduce__ = __reduce_cython__(...)\n",
      " |      Labels.__reduce_cython__(self)\n",
      " |  \n",
      " |  __repr__(self, /)\n",
      " |      Return repr(self).\n",
      " |  \n",
      " |  __setstate__ = __setstate_cython__(...)\n",
      " |      Labels.__setstate_cython__(self, __pyx_state)\n",
      " |  \n",
      " |  __str__(self, /)\n",
      " |      Return str(self).\n",
      " |  \n",
      " |  sort_by_size(...)\n",
      " |      Labels.sort_by_size(self, member_cutoff: Optional[int] = None, max_clusters: Optional[int] = None)\n",
      " |      Sort labels by clustersize in-place\n",
      " |      \n",
      " |              Re-assigns cluster numbers so that the biggest cluster (that is\n",
      " |              not noise) is cluster 1.  Also filters out clusters, that have\n",
      " |              not at least `member_cutoff` members.  Optionally, does only\n",
      " |              keep the `max_clusters` largest clusters.\n",
      " |      \n",
      " |              Args:\n",
      " |                 member_cutoff: Valid clusters need to have at least this\n",
      " |                    many members.\n",
      " |                 max_clusters: Only keep this many clusters.\n",
      " |  \n",
      " |  to_mapping(...)\n",
      " |      Labels.to_mapping(self)\n",
      " |      Convert labels container to `mapping` of labels to lists of point indices\n",
      " |  \n",
      " |  to_set(...)\n",
      " |      Labels.to_set(self)\n",
      " |      Convert labels container to `set` of unique labels\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Class methods defined here:\n",
      " |  \n",
      " |  from_sequence(...) from builtins.type\n",
      " |      Labels.from_sequence(type cls, labels, *, consider=None, meta=None) -> Type[Labels]\n",
      " |      Construct :obj:`Labels` from any sequence (not supporting the buffer protocol)\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Static methods defined here:\n",
      " |  \n",
      " |  __new__(*args, **kwargs) from builtins.type\n",
      " |      Create and return a new object.  See help(type) for accurate signature.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors defined here:\n",
      " |  \n",
      " |  consider\n",
      " |  \n",
      " |  consider_set\n",
      " |  \n",
      " |  labels\n",
      " |  \n",
      " |  mapping\n",
      " |  \n",
      " |  meta\n",
      " |      meta: dict\n",
      " |  \n",
      " |  n_points\n",
      " |  \n",
      " |  set\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(_types.Labels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "arctic-workshop",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:44:41.607172Z",
     "start_time": "2021-06-23T10:44:41.588506Z"
    }
   },
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "__cinit__() takes exactly 1 positional argument (0 given)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-5-a465ac6e3f53>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;31m# Requires labels to be initialised\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mlabels\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0m_types\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mLabels\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32msrc/cnnclustering/_types.pyx\u001b[0m in \u001b[0;36mcnnclustering._types.Labels.__cinit__\u001b[1;34m()\u001b[0m\n",
      "\u001b[1;31mTypeError\u001b[0m: __cinit__() takes exactly 1 positional argument (0 given)"
     ]
    }
   ],
   "source": [
    "# Requires labels to be initialised\n",
    "labels = _types.Labels()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "acoustic-implementation",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:46:29.368017Z",
     "start_time": "2021-06-23T10:46:29.363679Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Labels([1, 1, 2, 2, 0])"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "labels = _types.Labels(np.array([1, 1, 2, 2, 0]))\n",
    "labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "north-movement",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:46:30.152334Z",
     "start_time": "2021-06-23T10:46:30.149032Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1 1 2 2 0]\n"
     ]
    }
   ],
   "source": [
    "print(labels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "democratic-glenn",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:46:43.976530Z",
     "start_time": "2021-06-23T10:46:43.973247Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "cnnclustering._types.Labels"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(labels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "likely-applicant",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:45:21.350165Z",
     "start_time": "2021-06-23T10:45:21.341502Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1, 1, 2, 2, 0])"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "labels.labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "confidential-advertiser",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:47:10.095481Z",
     "start_time": "2021-06-23T10:47:10.090704Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'funny': 1}"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "labels.meta"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "neural-gothic",
   "metadata": {},
   "source": [
    "## Clustering"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "ethical-height",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:50:33.431084Z",
     "start_time": "2021-06-23T10:50:33.421550Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on class Clustering in module cnnclustering.cluster:\n",
      "\n",
      "class Clustering(builtins.object)\n",
      " |  Clustering(input_data=None, neighbours_getter=None, neighbours=None, neighbour_neighbours=None, metric=None, similarity_checker=None, queue=None, fitter=None, predictor=None, labels=None, alias: 'unicode' = 'root', parent=None)\n",
      " |  \n",
      " |  Represents a clustering endeavour\n",
      " |  \n",
      " |  A clustering object is made by aggregation of all necessary parts to\n",
      " |  carry out a clustering of input data points.\n",
      " |  \n",
      " |  Note:\n",
      " |      A clustering instance may also be created using the convenience\n",
      " |      function\n",
      " |      :func:`cnnclustering.cluster.prepare_clustering`\n",
      " |  \n",
      " |  Args:\n",
      " |      input_data: Any object implementing the input data interface.\n",
      " |          Represents the data points to be clustered.\n",
      " |      neighbours_getter: Any object implementing the neighbours\n",
      " |          getter interface. Controls how neighbours are\n",
      " |          retrieved/calculated from `input data`.\n",
      " |      neighbours: Any object implementing the neighbours\n",
      " |          interface.\n",
      " |          Represents neighbours found by the `neighbours_getter`.\n",
      " |      neighbour_neighbours: Same as `neighbours` but used for the\n",
      " |          neighbours of the neighbours.\n",
      " |      metric: Any object implementing the metric interface. Can be\n",
      " |          used by `neighbours_getter` to retrieved/calculated\n",
      " |          `neighbours` from `input data`.\n",
      " |      similarity_checker: Any object implementing the similarity\n",
      " |          checker interface. Evaluates if to points in `input_data`\n",
      " |          are part of the same cluster based on their `neighbours`.\n",
      " |      queue: Any object implementing the queue interface. May be\n",
      " |          used during the clustering procedure.\n",
      " |      fitter: Any object implementing the fitter interface. Executes\n",
      " |          the clustering procedure.\n",
      " |      predictor: Any object implementing the predictor interface.\n",
      " |          Translates a clustering result to another\n",
      " |          :obj:`cnnclustering.cluster.Clustering` object with different\n",
      " |          `input_data`.\n",
      " |      labels: An instance of :obj:`cnnclustering._types.Labels` holding\n",
      " |          cluster label assignments for points in `input_data`.\n",
      " |      alias: A descriptive string identifier associated with this\n",
      " |          clustering.\n",
      " |      parent: If not None, an instance of :obj:`cnnclustering.cluster.Clustering`\n",
      " |          of which this clustering is a child of.\n",
      " |  \n",
      " |  Attributes:\n",
      " |      input_data: A representation of the input data, typically a\n",
      " |          (list of) NumPy array(s). Shorthand for\n",
      " |          :obj:`self._input_data.data\n",
      " |      hierarchy_level: The level of this clustering in the hierarchical\n",
      " |          tree of clusterings (0 for the root instance).\n",
      " |      labels: Direct access to :obj:`cnnclustering._types.Labels.labels`\n",
      " |          holding\n",
      " |          cluster label assignments for points in `input_data`.\n",
      " |      children: A dictionary with child cluster labels as keys and\n",
      " |          :obj:`cnnclustering.cluster.Clustering` instances as values.\n",
      " |      summary: An instance of :obj:`cnnclustering.cluster.Summary`\n",
      " |          collecting clustering results.\n",
      " |  \n",
      " |  Methods defined here:\n",
      " |  \n",
      " |  __init__(self, input_data=None, neighbours_getter=None, neighbours=None, neighbour_neighbours=None, metric=None, similarity_checker=None, queue=None, fitter=None, predictor=None, labels=None, alias: 'unicode' = 'root', parent=None)\n",
      " |      Clustering.__init__(self, input_data=None, neighbours_getter=None, neighbours=None, neighbour_neighbours=None, metric=None, similarity_checker=None, queue=None, fitter=None, predictor=None, labels=None, unicode alias: str = u'root', parent=None)\n",
      " |  \n",
      " |  __repr__(self)\n",
      " |      Clustering.__repr__(self)\n",
      " |  \n",
      " |  __str__(self)\n",
      " |      Clustering.__str__(self)\n",
      " |  \n",
      " |  evaluate(self, ax=None, clusters: Union[Container[int], NoneType] = None, original: bool = False, plot_style: 'unicode' = 'dots', parts: Union[Tuple[Union[int, NoneType]], NoneType] = None, points: Union[Tuple[Union[int, NoneType]], NoneType] = None, dim: Union[Tuple[int, int], NoneType] = None, mask: Union[Sequence[Union[bool, int]], NoneType] = None, ax_props: Union[dict, NoneType] = None, annotate: bool = True, annotate_pos: 'unicode' = 'mean', annotate_props: Union[dict, NoneType] = None, plot_props: Union[dict, NoneType] = None, plot_noise_props: Union[dict, NoneType] = None, hist_props: Union[dict, NoneType] = None, free_energy: bool = True)\n",
      " |      Clustering.evaluate(self, ax=None, clusters: Optional[Container[int]] = None, original: bool = False, unicode plot_style: str = u'dots', parts: Optional[Tuple[Optional[int]]] = None, points: Optional[Tuple[Optional[int]]] = None, dim: Optional[Tuple[int, int]] = None, mask: Optional[Sequence[Union[bool, int]]] = None, ax_props: Optional[dict] = None, annotate: bool = True, unicode annotate_pos: str = u'mean', annotate_props: Optional[dict] = None, plot_props: Optional[dict] = None, plot_noise_props: Optional[dict] = None, hist_props: Optional[dict] = None, free_energy: bool = True)\n",
      " |      Returns a 2D plot of an original data set or a cluster result\n",
      " |      \n",
      " |              Args: ax: The `Axes` instance to which to add the plot.  If\n",
      " |                  `None`, a new `Figure` with `Axes` will be created.\n",
      " |      \n",
      " |                  clusters:\n",
      " |                      Cluster numbers to include in the plot.  If `None`,\n",
      " |                      consider all.\n",
      " |      \n",
      " |                  original:\n",
      " |                      Allows to plot the original data instead of a cluster\n",
      " |                      result.  Overrides `clusters`.  Will be considered\n",
      " |                      `True`, if no cluster result is present.\n",
      " |      \n",
      " |                  plot_style:\n",
      " |                      The kind of plotting method to use.\n",
      " |      \n",
      " |                          * \"dots\", :func:`ax.plot`\n",
      " |                          * \"scatter\", :func:`ax.scatter`\n",
      " |                          * \"contour\", :func:`ax.contour`\n",
      " |                          * \"contourf\", :func:`ax.contourf`\n",
      " |      \n",
      " |                  parts:\n",
      " |                      Use a slice (start, stop, stride) on the data parts\n",
      " |                      before plotting. Will be applied before a slice on `points`.\n",
      " |      \n",
      " |                  points:\n",
      " |                      Use a slice (start, stop, stride) on the data points\n",
      " |                      before plotting.\n",
      " |      \n",
      " |                  dim:\n",
      " |                      Use these two dimensions for plotting.  If `None`, uses\n",
      " |                      (0, 1).\n",
      " |      \n",
      " |                  mask:\n",
      " |                      Sequence of boolean or integer values used for optional\n",
      " |                      fancy indexing on the point data array.  Note, that this\n",
      " |                      is applied after regular slicing (e.g. via `points`) and\n",
      " |                      requires a copy of the indexed data (may be slow and\n",
      " |                      memory intensive for big data sets).\n",
      " |      \n",
      " |                  annotate:\n",
      " |                      If there is a cluster result, plot the cluster numbers.\n",
      " |                      Uses `annotate_pos` to determinte the position of the\n",
      " |                      annotations.\n",
      " |      \n",
      " |                  annotate_pos:\n",
      " |                      Where to put the cluster number annotation.\n",
      " |                      Can be one of:\n",
      " |      \n",
      " |                          * \"mean\", Use the cluster mean\n",
      " |                          * \"random\", Use a random point of the cluster\n",
      " |      \n",
      " |                      Alternatively a list of x, y positions can be passed to\n",
      " |                      set a specific point for each cluster\n",
      " |                      (*Not yet implemented*)\n",
      " |      \n",
      " |                  annotate_props:\n",
      " |                      Dictionary of keyword arguments passed to\n",
      " |                      :func:`ax.annotate`.\n",
      " |      \n",
      " |                  ax_props:\n",
      " |                      Dictionary of `ax` properties to apply after\n",
      " |                      plotting via :func:`ax.set(**ax_props)`.  If `None`,\n",
      " |                      uses defaults that can be also defined in\n",
      " |                      the configuration file (*Note yet implemented*).\n",
      " |      \n",
      " |                  plot_props:\n",
      " |                      Dictionary of keyword arguments passed to various\n",
      " |                      functions (:func:`plot.plot_dots` etc.) with different\n",
      " |                      meaning to format cluster plotting.  If `None`, uses\n",
      " |                      defaults that can be also defined in\n",
      " |                      the configuration file (*Note yet implemented*).\n",
      " |      \n",
      " |                  plot_noise_props:\n",
      " |                      Like `plot_props` but for formatting noise point\n",
      " |                      plotting.\n",
      " |      \n",
      " |                  hist_props:\n",
      " |                     Dictionary of keyword arguments passed to functions that\n",
      " |                     involve the computing of a histogram via\n",
      " |                     `numpy.histogram2d`.\n",
      " |      \n",
      " |                  free_energy:\n",
      " |                      If `True`, converts computed histograms to pseudo free\n",
      " |                      energy surfaces.\n",
      " |      \n",
      " |              Returns:\n",
      " |                  Figure, Axes and a list of plotted elements\n",
      " |  \n",
      " |  fit(self, radius_cutoff: 'float', cnn_cutoff: 'int', member_cutoff: 'int' = None, max_clusters: 'int' = None, cnn_offset: 'int' = None, sort_by_size: bool = True, info: bool = True, record: bool = True, record_time: bool = True, v: bool = True, purge: bool = False) -> None\n",
      " |      Clustering.fit(self, double radius_cutoff: float, cnn_cutoff: int, member_cutoff: int = None, max_clusters: int = None, cnn_offset: int = None, sort_by_size: bool = True, info: bool = True, record: bool = True, record_time: bool = True, v: bool = True, purge: bool = False) -> None\n",
      " |      Execute clustering procedure\n",
      " |      \n",
      " |              Args:\n",
      " |                  radius_cutoff: Neighbour search radius.\n",
      " |                  cnn_cutoff: Similarity criterion.\n",
      " |                  member_cutoff: Valid clusters need to have at least this\n",
      " |                      many members.  Passed on  to :meth:`Labels.sort_by_size`\n",
      " |                      if `sort_by_size` is `True`.  Has no effect otherwise\n",
      " |                      and valid clusters have at least one member.\n",
      " |                  max_clusters: Keep only the largest `max_clusters` clusters.\n",
      " |                      Passed on to :meth:`Labels.sort_by_size` if\n",
      " |                      `sort_by_size` is `True`.  Has no effect otherwise.\n",
      " |                  cnn_offset: Exists for compatibility reasons and is\n",
      " |                      substracted from `cnn_cutoff`.  If `cnn_offset = 0`, two\n",
      " |                      points need to share at least `cnn_cutoff` neighbours\n",
      " |                      to be part of the same cluster without counting any of\n",
      " |                      the two points.  In former versions of the clustering,\n",
      " |                      self-counting was included and `cnn_cutoff = 2` is\n",
      " |                      equivalent to `cnn_cutoff = 0` in this version.\n",
      " |                  sort_by_size: Weather to sort (and trim) the created\n",
      " |                      :obj:`Labels` instance.  See also\n",
      " |                      :meth:`Labels.sort_by_size`.\n",
      " |                  info: Wether to modify :obj:`Labels.meta` information for\n",
      " |                      this clustering.\n",
      " |                  record: Wether to create a :obj:`Record`\n",
      " |                      instance for this clustering which is appended to the\n",
      " |                      :obj:`Summary`.\n",
      " |                  record_time: Wether to time clustering execution.\n",
      " |                  v: Be chatty.\n",
      " |                  purge: If True, force re-initialisation of cluster label\n",
      " |                      assignments.\n",
      " |  \n",
      " |  fit_hierarchical(self, radius_cutoff: Union[float, List[float]], cnn_cutoff: Union[int, List[int]], member_cutoff: 'int' = None, max_clusters: 'int' = None, cnn_offset: 'int' = None)\n",
      " |      Clustering.fit_hierarchical(self, radius_cutoff: Union[float, List[float]], cnn_cutoff: Union[int, List[int]], member_cutoff: int = None, max_clusters: int = None, cnn_offset: int = None)\n",
      " |      Execute hierarchical clustering procedure\n",
      " |  \n",
      " |  get_child(self, label)\n",
      " |      Clustering.get_child(self, label)\n",
      " |  \n",
      " |  isolate(self, purge: bool = True, isolate_input_data: bool = True)\n",
      " |      Clustering.isolate(self, bool purge: bool = True, bool isolate_input_data: bool = True)\n",
      " |      Create child clusterings from cluster labels\n",
      " |      \n",
      " |              Args:\n",
      " |                  purge: If `True`, creates a new mapping for the children of this\n",
      " |                      clustering.\n",
      " |                  isolate_input_data: If `True`, attaches a subset of the input data\n",
      " |                      of this clustering to the child.\n",
      " |  \n",
      " |  pie(self, ax=None, pie_props=None)\n",
      " |      Clustering.pie(self, ax=None, pie_props=None)\n",
      " |  \n",
      " |  predict(self, other: Type[ForwardRef('Clustering')], radius_cutoff: 'float', cnn_cutoff: 'int', clusters: Union[Sequence[int], NoneType] = None, cnn_offset: Union[int, NoneType] = None, info: bool = True, record: bool = True, record_time: bool = True, v: bool = True, purge: bool = False)\n",
      " |      Clustering.predict(self, other: Type[u'Clustering'], double radius_cutoff: float, cnn_cutoff: int, clusters: Optional[Sequence[int]] = None, cnn_offset: Optional[int] = None, info: bool = True, record: bool = True, record_time: bool = True, v: bool = True, purge: bool = False)\n",
      " |      Execute prediction procedure\n",
      " |      \n",
      " |              Args:\n",
      " |                  other: :obj:`cnnclustering.cluster.Clustering` instance for\n",
      " |                      which cluster labels should be predicted.\n",
      " |                  radius_cutoff: Neighbour search radius.\n",
      " |                  cnn_cutoff: Similarity criterion.\n",
      " |                  cluster: Sequence of cluster labels that should be included\n",
      " |                     in the prediction.\n",
      " |                  cnn_offset: Exists for compatibility reasons and is\n",
      " |                      substracted from `cnn_cutoff`.  If `cnn_offset = 0`, two\n",
      " |                      points need to share at least `cnn_cutoff` neighbours\n",
      " |                      to be part of the same cluster without counting any of\n",
      " |                      the two points.  In former versions of the clustering,\n",
      " |                      self-counting was included and `cnn_cutoff = 2` is\n",
      " |                      equivalent to `cnn_cutoff = 0` in this version.\n",
      " |                  purge: If True, force re-initialisation of predicted cluster\n",
      " |                      labels.\n",
      " |  \n",
      " |  reel(self, depth: Union[int, NoneType] = None) -> None\n",
      " |      Clustering.reel(self, depth: Optional[int] = None) -> None\n",
      " |      Wrap up label assignments of lower hierarchy levels\n",
      " |      \n",
      " |              Args:\n",
      " |                  depth: How many lower levels to consider. If `None`,\n",
      " |                  consider all.\n",
      " |  \n",
      " |  summarize(self, ax=None, quantity: 'unicode' = 'execution_time', treat_nan: Union[Any, NoneType] = None, convert: Union[Any, NoneType] = None, ax_props: Union[dict, NoneType] = None, contour_props: Union[dict, NoneType] = None, plot_style: 'unicode' = 'contourf')\n",
      " |      Clustering.summarize(self, ax=None, unicode quantity: str = u'execution_time', treat_nan: Optional[Any] = None, convert: Optional[Any] = None, ax_props: Optional[dict] = None, contour_props: Optional[dict] = None, unicode plot_style: str = u'contourf')\n",
      " |      Generate a 2D plot of record values\n",
      " |      \n",
      " |              Record values (\"time\", \"clusters\", \"largest\", \"noise\") are\n",
      " |              plotted against cluster parameters (radius cutoff *r*\n",
      " |              and cnn cutoff *c*).\n",
      " |      \n",
      " |              Args:\n",
      " |                  ax: Matplotlib Axes to plot on.  If `None`, a new Figure\n",
      " |                      with Axes will be created.\n",
      " |                  quantity: Record value to\n",
      " |                      visualise:\n",
      " |      \n",
      " |                          * \"time\"\n",
      " |                          * \"clusters\"\n",
      " |                          * \"largest\"\n",
      " |                          * \"noise\"\n",
      " |      \n",
      " |                  treat_nan: If not `None`, use this value to pad nan-values.\n",
      " |                  ax_props: Used to style `ax`.\n",
      " |                  contour_props: Passed on to contour.\n",
      " |  \n",
      " |  to_nx_DiGraph(self, ignore=None)\n",
      " |      Clustering.to_nx_DiGraph(self, ignore=None)\n",
      " |      Convert cluster hierarchy to networkx DiGraph\n",
      " |      \n",
      " |              Keyword args:\n",
      " |                  ignore: A set of label not to include into the graph.  Use\n",
      " |                      for example to exclude noise (label 0).\n",
      " |  \n",
      " |  tree(self, ax=None, ignore=None, pos_props=None, draw_props=None)\n",
      " |      Clustering.tree(self, ax=None, ignore=None, pos_props=None, draw_props=None)\n",
      " |  \n",
      " |  trim_shrinking_leafs(self)\n",
      " |      Clustering.trim_shrinking_leafs(self)\n",
      " |  \n",
      " |  trim_trivial_leafs(self)\n",
      " |      Clustering.trim_trivial_leafs(self)\n",
      " |      Scan cluster hierarchy for removable nodes\n",
      " |      \n",
      " |              If the cluster label assignments on a clustering are all zero\n",
      " |              (noise), the clustering is considered trivial.  In this case,\n",
      " |              the labels and children are reset to `None`.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Readonly properties defined here:\n",
      " |  \n",
      " |  children\n",
      " |      Clustering.children(self)\n",
      " |  \n",
      " |  input_data\n",
      " |      Clustering.input_data(self)\n",
      " |  \n",
      " |  summary\n",
      " |      Clustering.summary(self)\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors defined here:\n",
      " |  \n",
      " |  __dict__\n",
      " |      dictionary for instance variables (if defined)\n",
      " |  \n",
      " |  __weakref__\n",
      " |      list of weak references to the object (if defined)\n",
      " |  \n",
      " |  hierarchy_level\n",
      " |      Clustering.hierarchy_level(self)\n",
      " |  \n",
      " |  labels\n",
      " |      Clustering.labels(self)\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data and other attributes defined here:\n",
      " |  \n",
      " |  take_over_attrs = ['_neighbours_getter', '_neighbours', '_neighbour_ne...\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(cluster.Clustering)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "moving-ballot",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:49:56.304268Z",
     "start_time": "2021-06-23T10:49:56.300168Z"
    }
   },
   "outputs": [],
   "source": [
    "clustering = cluster.Clustering()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "pressing-restaurant",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:50:03.608124Z",
     "start_time": "2021-06-23T10:50:03.604841Z"
    }
   },
   "outputs": [],
   "source": [
    "clustering.labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "virgin-thunder",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:51:13.609460Z",
     "start_time": "2021-06-23T10:51:13.607067Z"
    }
   },
   "outputs": [],
   "source": [
    "clustering = cluster.Clustering(labels=labels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "alert-dynamics",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:51:27.224631Z",
     "start_time": "2021-06-23T10:51:27.221656Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Labels([1, 1, 2, 2, 0])"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "clustering._labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "geographic-nature",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-06-23T10:51:19.725400Z",
     "start_time": "2021-06-23T10:51:19.719580Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1, 1, 2, 2, 0])"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "clustering.labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "needed-resource",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "cnnclustering38",
   "language": "python",
   "name": "cnnclustering38"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": true,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": true,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
