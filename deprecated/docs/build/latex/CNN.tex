%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{CNN Documentation}
\date{Dec 03, 2018}
\release{0.1}
\author{Jan-Oliver Joswig}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Installation}
\label{\detokenize{installation:installation}}\label{\detokenize{installation::doc}}
Get the source:

git clone \sphinxurl{https://github.com/janjoswig/CNN.git}

To use the cnn module add it to your PYTHONPATH:

export PYTHONPATH=\$PYTHONPATH:\$YOUR\_DIR/CNN/cnn

To use the executables:

export PATH=\$PATH:\$YOUR\_DIR/CNN/bin

or create a symlink, e.g.

ln -s \$YOUR\_DIR/CNN/bin/cnn \$YOUR\_FAVORITE\_DIR/cnn


\chapter{Getting started}
\label{\detokenize{gettingstarted:getting-started}}\label{\detokenize{gettingstarted::doc}}
The cnn module provides a data set based API for
common-nearest-neighbour clustering. The core functionality is bundled
in a class \sphinxcode{\sphinxupquote{cnn.CNN()}}. Here is a minimal example of its usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{cnn}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj} \PYG{o}{=} \PYG{n}{cnn}\PYG{o}{.}\PYG{n}{CNN}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{path\PYGZus{}to\PYGZus{}data/data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

After importing the main module, this creates an instance of the cnn
cluster class. Data is loaded into the object and fitted, i.e.
clustered by the cnn algorithm.

Let’s go a bit deeper. Call of a cluster objects \sphinxcode{\sphinxupquote{\_\_str\_\_()}}
gives us an overview of its properties.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj} \PYG{o}{=} \PYG{n}{cnn}\PYG{o}{.}\PYG{n}{CNN}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cobj}\PYG{p}{)}
\PYG{g+go}{cnn.CNN() cluster object}
\PYG{g+go}{alias :                                 root}
\PYG{g+go}{hierachy level:                         0}
\PYG{g+go}{test data loaded :                      False}
\PYG{g+go}{test data shape :                       None}
\PYG{g+go}{train data loaded :                     False}
\PYG{g+go}{train data shape :                      None}
\PYG{g+go}{distance matrix calculated (train):     False}
\PYG{g+go}{distance matrix calculated (test):      False}
\PYG{g+go}{clustered :                             False}
\PYG{g+go}{children :                              False}
\end{sphinxVerbatim}

A freshly created cluster object is by default called \sphinxstyleemphasis{root}. It has the highest possible hierarchy level 0 (more on this later). No data is present as indicated by \sphinxstyleemphasis{data loaded : False} and nothing has been done so far. Data is either treated as \sphinxstyleemphasis{test} or \sphinxstyleemphasis{train} to allow for clustering on one set and interpolation on another. We will see how, but first we need some data:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k}{import} \PYG{n}{datasets}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{preprocessing} \PYG{k}{import} \PYG{n}{StandardScaler}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{blobs}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{datasets}\PYG{o}{.}\PYG{n}{make\PYGZus{}blobs}\PYG{p}{(}\PYG{n}{n\PYGZus{}samples}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,}
\PYG{g+gp}{... }                               \PYG{n}{cluster\PYGZus{}std}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.1}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }                               \PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{blobs} \PYG{o}{=} \PYG{n}{StandardScaler}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit\PYGZus{}transform}\PYG{p}{(}\PYG{n}{blobs}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj} \PYG{o}{=} \PYG{n}{cnn}\PYG{o}{.}\PYG{n}{CNN}\PYG{p}{(}\PYG{n}{test}\PYG{o}{=}\PYG{n}{blobs}\PYG{p}{)}
\end{sphinxVerbatim}

When we now look at our object again, its properties have changed:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cobj}\PYG{p}{)}
\PYG{g+go}{cnn.CNN() cluster object}
\PYG{g+go}{alias :                                 root}
\PYG{g+go}{hierachy level:                         0}
\PYG{g+go}{test data loaded :                      True}
\PYG{g+go}{test data shape :                       \PYGZob{}\PYGZsq{}parts\PYGZsq{}: 1, \PYGZsq{}points\PYGZsq{}: [10000], \PYGZsq{}dimensions\PYGZsq{}: 2\PYGZcb{}}
\PYG{g+go}{train data loaded :                     False}
\PYG{g+go}{train data shape :                      None}
\PYG{g+go}{distance matrix calculated (train):     False}
\PYG{g+go}{distance matrix calculated (test):      False}
\PYG{g+go}{clustered :                             False}
\PYG{g+go}{children :                              False}
\end{sphinxVerbatim}

Data is now present as \sphinxstyleemphasis{test}. All data is processed as numpy array of
the form (\sphinxstyleemphasis{parts} x \sphinxstyleemphasis{points} x \sphinxstyleemphasis{dimensions}). Data can be passed to the
CNN() class as 1-D (only one part, points in only one dimension) or 2-D
(one part, points in \sphinxstyleemphasis{n} dimensions) array-like structure, but will be
processed internally in this general shape. In the \sphinxstyleemphasis{shape} dictionary,
\sphinxcode{\sphinxupquote{cobj.test\_shape}}, \sphinxcode{\sphinxupquote{'points'}} is associated with a list of data
points per part.

We can get an impression of the loaded data by plotting the points.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{blobs}.png}
\end{figure}

Let’s reduce the large \sphinxstyleemphasis{test} data set to make the clustering faster.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{cut}\PYG{p}{(}\PYG{n}{points}\PYG{o}{=}\PYG{p}{(}\PYG{k+kc}{None}\PYG{p}{,} \PYG{k+kc}{None}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cobj}\PYG{p}{)}
\PYG{g+go}{cnn.CNN() cluster object}
\PYG{g+go}{alias :                                 root}
\PYG{g+go}{hierachy level:                         0}
\PYG{g+go}{test data loaded :                      True}
\PYG{g+go}{test data shape :                       \PYGZob{}\PYGZsq{}parts\PYGZsq{}: 1, \PYGZsq{}points\PYGZsq{}: [10000], \PYGZsq{}dimensions\PYGZsq{}: 2\PYGZcb{}}
\PYG{g+go}{train data loaded :                     True}
\PYG{g+go}{train data shape :                      \PYGZob{}\PYGZsq{}parts\PYGZsq{}: 1, \PYGZsq{}points\PYGZsq{}: [1000], \PYGZsq{}dimensions\PYGZsq{}: 2\PYGZcb{}}
\PYG{g+go}{distance matrix calculated (train):     False}
\PYG{g+go}{distance matrix calculated (test):      False}
\PYG{g+go}{clustered :                             False}
\PYG{g+go}{children :                              False}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{blobs_train}.png}
\end{figure}

Plotting the pairwise distance distribution of the data set can be
useful, too. Multiple peaks in this distribution hint to the presence
of more than one cluster and the location of the peaks can help in
finding an appropriate \sphinxcode{\sphinxupquote{radius\_cutoff}} to start with. If we want to
separate a cluster from the bulk, the \sphinxcode{\sphinxupquote{radius\_cutoff}} needs to be
smaller than the maximum of the peak associated with it.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{dist\PYGZus{}hist}\PYG{p}{(}\PYG{n}{maxima}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{Train distance matrix not calculated. Calculating distance matrix.}
\PYG{g+go}{Calculating nxn distance matrix for 1000 points}
\PYG{g+go}{Execution time for call of dist(): 0 hours, 0 minutes, 0.0165 seconds}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{blobs_train_dist_matrix}.png}
\end{figure}

So let’s try fitting our data to some parameters.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{radius\PYGZus{}cutoff}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{cnn\PYGZus{}cutoff}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}
\PYG{g+go}{Execution time for call of fit(): 0 hours, 0 minutes, 0.2588 seconds}
\PYG{g+go}{recording: ...}
\PYG{g+go}{points               1000}
\PYG{g+go}{radius\PYGZus{}cutoff           1}
\PYG{g+go}{cnn\PYGZus{}cutoff             20}
\PYG{g+go}{member\PYGZus{}cutoff           1}
\PYG{g+go}{max\PYGZus{}clusters         None}
\PYG{g+go}{n\PYGZus{}clusters              2}
\PYG{g+go}{largest             0.658}
\PYG{g+go}{noise               0.001}
\PYG{g+go}{time             0.258785}
\PYG{g+go}{dtype: object}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{blobs_train_cluster_I}.png}
\end{figure}

All calls of \sphinxcode{\sphinxupquote{cobj.fit()}} are recorded and stored in a pandas data
frame.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{summary}\PYG{o}{.}\PYG{n}{sort\PYGZus{}values}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n\PYGZus{}clusters}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{  points radius\PYGZus{}cutoff cnn\PYGZus{}cutoff member\PYGZus{}cutoff max\PYGZus{}clusters n\PYGZus{}clusters  largest  noise      time}
\PYG{g+go}{0   1000             2         10             1         None          1    1.000  0.000  0.374373}
\PYG{g+go}{1   1000             2         20             1         None          1    1.000  0.000  0.365650}
\PYG{g+go}{2   1000           1.5         20             1         None          1    1.000  0.000  0.362920}
\PYG{g+go}{3   1000             1         20             1         None          2    0.658  0.001  0.258785}
\end{sphinxVerbatim}

The cluster result itself is stored in two instance variables,
\sphinxcode{\sphinxupquote{cobj.train\_labels}} (cluster label assignments for each point) and
\sphinxcode{\sphinxupquote{cobj.train\_clusterdict}} (points associated to cluster label keys).
Noise points are labeled by 0.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cluster labels: }\PYG{l+s+si}{\PYGZob{}cobj.train\PYGZus{}labels[:10]\PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{... }\PYG{l+s+s2}{Shape: }\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{np.shape(cobj.train\PYGZus{}labels)\PYGZcb{}, }\PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{... }\PYG{l+s+s2}{Type: }\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{type(cobj.train\PYGZus{}labels)\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{Cluster labels: [2 2 1 1 2 1 2 1 1 1], Shape: (1000,), Type: \PYGZlt{}class \PYGZsq{}numpy.ndarray\PYGZsq{}\PYGZgt{}}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cluster dictionary: }\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{cobj.train\PYGZus{}clusterdict.keys()\PYGZcb{}, }\PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{... }\PYG{l+s+s2}{Shape: }\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{[len(x) for x in cobj.train\PYGZus{}clusterdict.values()]\PYGZcb{}, }\PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{... }\PYG{l+s+s2}{Type: }\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{type(cobj.train\PYGZus{}clusterdict)\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{Cluster dictionary: dict\PYGZus{}keys([0, 1, 2]), Shape: [1, 658, 341], Type: \PYGZlt{}class \PYGZsq{}collections.defaultdict\PYGZsq{}\PYGZgt{}}
\end{sphinxVerbatim}

This first fit devided the data set into two clusters. As
can be clearly seen from the evaluation above, the blue cluster
(label 1) could be further splitted. Before we attempt this, we need to
isolate the clusters found, i.e. we create a new cluster object for each
one of them. These \sphinxstyleemphasis{child} objects of our \sphinxstyleemphasis{root} data set are stored in
a dictionary \sphinxcode{\sphinxupquote{cobj.train\_children}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{isolate}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{train\PYGZus{}children}
\PYG{g+go}{defaultdict(\PYGZlt{}function cnn.CNN.isolate.\PYGZlt{}locals\PYGZgt{}.\PYGZlt{}lambda\PYGZgt{}()\PYGZgt{},}
\PYG{g+go}{            \PYGZob{}0: \PYGZlt{}cnn.CNNChild at 0x7f1397bdf470\PYGZgt{},}
\PYG{g+go}{             1: \PYGZlt{}cnn.CNNChild at 0x7f1397bc2cf8\PYGZgt{},}
\PYG{g+go}{             2: \PYGZlt{}cnn.CNNChild at 0x7f1397b58940\PYGZgt{}\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{train\PYGZus{}children}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{cnn.CNN() cluster object}
\PYG{g+go}{alias :                                 child No. 1}
\PYG{g+go}{hierachy level:                         1}
\PYG{g+go}{test data loaded :                      False}
\PYG{g+go}{test data shape :                       None}
\PYG{g+go}{train data loaded :                     True}
\PYG{g+go}{train data shape :                      \PYGZob{}\PYGZsq{}parts\PYGZsq{}: 1, \PYGZsq{}points\PYGZsq{}: [658], \PYGZsq{}dimensions\PYGZsq{}: 2\PYGZcb{}}
\PYG{g+go}{distance matrix calculated (train):     False}
\PYG{g+go}{distance matrix calculated (test):      False}
\PYG{g+go}{clustered :                             False}
\PYG{g+go}{children :                              False}
\end{sphinxVerbatim}

A child cluster class instance of cnn.CNNChild() is a fully functional
cluster object itself. New, as shown above, is here that the hierarchy
level was incremented by one. We can now look at the distance
distribution of the data subset in \sphinxstyleemphasis{child No. 1}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{train\PYGZus{}children}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dist\PYGZus{}hist}\PYG{p}{(}\PYG{n}{maxima}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{Train distance matrix not calculated. Calculating distance matrix.}
\PYG{g+go}{Calculating nxn distance matrix for 658 points}
\PYG{g+go}{Execution time for call of dist(): 0 hours, 0 minutes, 0.0073 seconds}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{blobs_train_child1_dist_matrix}.png}
\end{figure}

And we can fit with adjusted parameters.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{train\PYGZus{}children}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{radius\PYGZus{}cutoff}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{,}
\PYG{g+go}{                               cnn\PYGZus{}cutoff=20,}
\PYG{g+go}{                               member\PYGZus{}cutoff=5)}
\PYG{g+go}{Execution time for call of fit(): 0 hours, 0 minutes, 0.1330 seconds}
\PYG{g+go}{recording: ...}
\PYG{g+go}{points                658}
\PYG{g+go}{radius\PYGZus{}cutoff         0.3}
\PYG{g+go}{cnn\PYGZus{}cutoff             20}
\PYG{g+go}{member\PYGZus{}cutoff           5}
\PYG{g+go}{max\PYGZus{}clusters         None}
\PYG{g+go}{n\PYGZus{}clusters              2}
\PYG{g+go}{largest               0.5}
\PYG{g+go}{noise             0.12766}
\PYG{g+go}{time             0.132971}
\PYG{g+go}{dtype: object}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{blobs_train_cluster_II}.png}
\end{figure}

When we are satisfied by the outcome, putting everything back together
is easy.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{train\PYGZus{}children}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{train\PYGZus{}clusterdict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{n}{dict\PYGZus{}keys}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{train\PYGZus{}clusterdict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{n}{dict\PYGZus{}keys}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{reel}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{train\PYGZus{}clusterdict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{n}{dict\PYGZus{}keys}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{blobs_train_cluster_III}.png}
\end{figure}

Lastly we want to map the larger \sphinxstyleemphasis{test} data set onto our result. While
this is possible for all clusters at once, it can be nice to predict the
assignement of \sphinxstyleemphasis{test} points to the \sphinxstyleemphasis{train} clusters for each set using
individual parameters.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{radius\PYGZus{}cutoff}\PYG{o}{=}\PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{n}{cnn\PYGZus{}cutoff}\PYG{o}{=}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{n}{cluster}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{Predicting cluster for point  10000 of 10000}
\PYG{g+go}{Execution time for call of predict(): 0 hours, 0 minutes, 77.2176 seconds}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{blobs_predict_cluster_I}.png}
\end{figure}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{radius\PYGZus{}cutoff}\PYG{o}{=}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{n}{cnn\PYGZus{}cutoff}\PYG{o}{=}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{n}{cluster}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{Predicting cluster for point  10000 of 10000}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{radius\PYGZus{}cutoff}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{n}{cnn\PYGZus{}cutoff}\PYG{o}{=}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{n}{cluster}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{Predicting cluster for point  10000 of 10000}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cobj}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{blobs_predict_cluster_II}.png}
\end{figure}

The predicted cluster result is then stored in the complementary
instance variables \sphinxcode{\sphinxupquote{cobj.test\_labels}} and \sphinxcode{\sphinxupquote{cobj.test\_clusterdict}}.
Et voilà!

How certain aspects of the module behave is defined by a config file,
which is automatically tried to be saved in the users home directory as
.cnnrc. A config file in the current working directory overides all
settings.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pathlib}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{pathlib.Path.home()\PYGZcb{}/.cnnrc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{file\PYGZus{}}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{file\PYGZus{}}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\PYG{g+go}{[settings]}
\PYG{g+go}{record\PYGZus{}points = points}
\PYG{g+go}{record\PYGZus{}radius\PYGZus{}cutoff = radius\PYGZus{}cutoff}
\PYG{g+go}{record\PYGZus{}cnn\PYGZus{}cutoff = cnn\PYGZus{}cutoff}
\PYG{g+go}{record\PYGZus{}member\PYGZus{}cutoff = member\PYGZus{}cutoff}
\PYG{g+go}{record\PYGZus{}max\PYGZus{}cluster = max\PYGZus{}cluster}
\PYG{g+go}{record\PYGZus{}n\PYGZus{}cluster = n\PYGZus{}cluster}
\PYG{g+go}{record\PYGZus{}largest = largest}
\PYG{g+go}{record\PYGZus{}noise = noise}
\PYG{g+go}{record\PYGZus{}time = time}
\PYG{g+go}{default\PYGZus{}radius\PYGZus{}cutoff = 1}
\PYG{g+go}{default\PYGZus{}cnn\PYGZus{}cutoff = 1}
\PYG{g+go}{default\PYGZus{}member\PYGZus{}cutoff = 0}
\PYG{g+go}{color = \PYGZsh{}000000 \PYGZsh{}396ab1 \PYGZsh{}da7c30 \PYGZsh{}3e9651 \PYGZsh{}cc2529 \PYGZsh{}535154}
\PYG{g+go}{        \PYGZsh{}6b4c9a \PYGZsh{}922428 \PYGZsh{}948b3d \PYGZsh{}7293cb \PYGZsh{}e1974c \PYGZsh{}84ba5b}
\PYG{g+go}{        \PYGZsh{}d35e60 \PYGZsh{}9067a7 \PYGZsh{}ab6857 \PYGZsh{}ccc210 \PYGZsh{}808585}
\end{sphinxVerbatim}


\chapter{Documentation}
\label{\detokenize{documentation:module-cnn}}\label{\detokenize{documentation:documentation}}\label{\detokenize{documentation::doc}}\index{cnn (module)}
This is cnn v0.1

The functionality provided in this module is based on code implemented
by Oliver Lemke in the script collection CNNClustering available on
git-hub (\sphinxurl{https://github.com/BDGSoftware/CNNClustering.git}).

Author: Jan-Oliver Joswig, 
first released: 03.12.2018
\index{CNN (class in cnn)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{cnn.}}\sphinxbfcode{\sphinxupquote{CNN}}}{\emph{alias='root'}, \emph{train=None}, \emph{test=None}, \emph{train\_dist\_matrix=None}, \emph{test\_dist\_matrix=None}, \emph{map\_matrix=None}}{}
CNN cluster object class
\index{cut() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.cut}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cut}}}{\emph{parts=(None}, \emph{None}, \emph{None)}, \emph{points=(None}, \emph{None}, \emph{None)}, \emph{dimensions=(None}, \emph{None}, \emph{None)}}{}
Alows data set reduction.  For each data set level (parts,
points, dimensions) a tuple (start:stop:step) can be
specified.

\end{fulllineitems}

\index{dist() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.dist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dist}}}{\emph{mode='train'}, \emph{low\_memory=False}}{}
Computes a distance matrix (points x points) for points in given data
of standard shape (parts, points, dimensions)

\end{fulllineitems}

\index{dist\_hist() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.dist_hist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dist\_hist}}}{\emph{mode='train'}, \emph{bins=100}, \emph{range=None}, \emph{density=True}, \emph{weights=None}, \emph{xlabel='d / au'}, \emph{ylabel=''}, \emph{show=True}, \emph{save=False}, \emph{output='dist\_hist.pdf'}, \emph{dpi=300}, \emph{maxima=False}}{}
Shows/saves a histogram plot for distances in a given distance
matrix

\end{fulllineitems}

\index{evaluate() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.evaluate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate}}}{\emph{mode='train'}, \emph{max\_clusters=None}, \emph{plot='scatter'}, \emph{parts=(None}, \emph{None}, \emph{None)}, \emph{points=(None}, \emph{None}, \emph{None)}, \emph{dim=None}, \emph{show=True}, \emph{save=False}, \emph{output='evaluation.pdf'}, \emph{dpi=300}}{}
Shows/saves a 2D histogram or scatter plot of a cluster result

\end{fulllineitems}

\index{fit() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.fit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fit}}}{\emph{radius\_cutoff=None}, \emph{cnn\_cutoff=None}, \emph{member\_cutoff=None}, \emph{max\_clusters=None}, \emph{rec=True}}{}
Performs a CNN clustering of points in a given train 
distance matrix

\end{fulllineitems}

\index{get\_shape() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.get_shape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_shape}}}{\emph{data}}{}
Analyses the format of given data and fits it into standard
format (parts, points, dimensions).

\end{fulllineitems}

\index{isolate() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.isolate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isolate}}}{\emph{mode='train'}, \emph{purge=True}}{}
Isolates points per clusters based on a cluster result

\end{fulllineitems}

\index{load() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{\emph{file\_}, \emph{mode='train'}}{}
Loads file content and return data and shape

\end{fulllineitems}

\index{map() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.map}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{map}}}{\emph{nearest=None}}{}
Computes a map matrix that maps an arbitrary data set to a
reduced to set

\end{fulllineitems}

\index{query\_data() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.query_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query\_data}}}{\emph{mode='train'}}{}
Helper function to evaluate user input. If data is required as
keyword argument and data=None is passed, the default data used is
either self.rdata or self.data.

\end{fulllineitems}

\index{save() (cnn.CNN method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNN.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{file\_}, \emph{content}}{}
Saves content to file

\end{fulllineitems}


\end{fulllineitems}

\index{CNNChild (class in cnn)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.CNNChild}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{cnn.}}\sphinxbfcode{\sphinxupquote{CNNChild}}}{\emph{parent}}{}
CNN cluster object subclass. Increments the hierarchy level of
the parent object when instanciated.

\end{fulllineitems}

\index{dist() (in module cnn)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.dist}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cnn.}}\sphinxbfcode{\sphinxupquote{dist}}}{\emph{data}}{}
High level wrapper function for cnn.CNN().dist(). Takes data and
returns a distance matrix (points x points).

\end{fulllineitems}

\index{recorded() (in module cnn)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.recorded}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cnn.}}\sphinxbfcode{\sphinxupquote{recorded}}}{\emph{function\_}}{}
Decorator to format function feedback.  Feedback needs to be
pandas series in record format.  If execution time was measured,
this will be included in the summary.

\end{fulllineitems}

\index{timed() (in module cnn)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:cnn.timed}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cnn.}}\sphinxbfcode{\sphinxupquote{timed}}}{\emph{function\_}}{}
Decorator to measure execution time.  Forwards the output of the
wrapped function and measured excecution time.

\end{fulllineitems}



\chapter{Changelog}
\label{\detokenize{changelog:changelog}}\label{\detokenize{changelog::doc}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\sphinxstyleindexentry{cnn}}\sphinxstyleindexpageref{documentation:\detokenize{module-cnn}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}